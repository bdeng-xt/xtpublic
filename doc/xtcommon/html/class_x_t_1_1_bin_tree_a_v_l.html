<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xtcommon: XT::BinTreeAVL&lt; T, TCompare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xtcommon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>XT</b></li><li class="navelem"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_x_t_1_1_bin_tree_a_v_l-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XT::BinTreeAVL&lt; T, TCompare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive balanced AVL binary tree container.  
 <a href="class_x_t_1_1_bin_tree_a_v_l.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x_t_bin_tree_a_v_l_8h_source.html">XTBinTreeAVL.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_t_1_1_bin_tree_a_v_l_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVL binary tree node.  <a href="struct_x_t_1_1_bin_tree_a_v_l_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac0f2b6ab6802e88b6a4cdd60b1a08392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f2b6ab6802e88b6a4cdd60b1a08392"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ac0f2b6ab6802e88b6a4cdd60b1a08392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72441401000110b27dd58dde8fb1173b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72441401000110b27dd58dde8fb1173b"></a>
typedef TCompare&#160;</td><td class="memItemRight" valign="bottom"><b>value_compare</b></td></tr>
<tr class="separator:a72441401000110b27dd58dde8fb1173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5337bac23df23c5190506ed44344aee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5337bac23df23c5190506ed44344aee6"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a5337bac23df23c5190506ed44344aee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034c1ea7ee3dfa1f75af14b55c284c23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034c1ea7ee3dfa1f75af14b55c284c23"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a034c1ea7ee3dfa1f75af14b55c284c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b770af489679dfb9078fc799d670730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b770af489679dfb9078fc799d670730"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a6b770af489679dfb9078fc799d670730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0104b309f1acdf46562db52457dbf80f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0104b309f1acdf46562db52457dbf80f"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a0104b309f1acdf46562db52457dbf80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f2c2fa6a934d755fa404a4f1b209a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a094f2c2fa6a934d755fa404a4f1b209a"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a094f2c2fa6a934d755fa404a4f1b209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7160a57123b7584604b901bfa484376e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7160a57123b7584604b901bfa484376e"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a7160a57123b7584604b901bfa484376e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae096989169bebe441db4380664841f6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae096989169bebe441db4380664841f6e"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">BinTreeIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ae096989169bebe441db4380664841f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc05182e8efbee17e3c678530e86a62e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc05182e8efbee17e3c678530e86a62e"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">BinTreeConstIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:abc05182e8efbee17e3c678530e86a62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1654a5076eba3265a6cabf001b3501bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1654a5076eba3265a6cabf001b3501bd"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">BinTreeReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a1654a5076eba3265a6cabf001b3501bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37161cef339bb4c812c7745be05b1d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af37161cef339bb4c812c7745be05b1d0"></a>
typedef <br class="typebreak"/>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">BinTreeConstReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:af37161cef339bb4c812c7745be05b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a571660459fcfddbdc325256b0939fc2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a571660459fcfddbdc325256b0939fc2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTreeAVL</b> (const TCompare &amp;<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a112d53f0960d46aeedd15d554e7e1b28">compare</a>=TCompare()) noexcept</td></tr>
<tr class="separator:a571660459fcfddbdc325256b0939fc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fe67906f4aa18cdba214617b1952ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9fe67906f4aa18cdba214617b1952ba"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa9fe67906f4aa18cdba214617b1952ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BinTreeAVL</b> (InputIterator first, InputIterator last, const TCompare &amp;<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a112d53f0960d46aeedd15d554e7e1b28">compare</a>=TCompare()) noexcept</td></tr>
<tr class="separator:aa9fe67906f4aa18cdba214617b1952ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea39e4ecd0a902cb8b8da079ae5ea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ea39e4ecd0a902cb8b8da079ae5ea4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTreeAVL</b> (const <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;) noexcept=default</td></tr>
<tr class="separator:ae3ea39e4ecd0a902cb8b8da079ae5ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7200c05d495fa11eee9d3c54b9204a95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7200c05d495fa11eee9d3c54b9204a95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTreeAVL</b> (<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7200c05d495fa11eee9d3c54b9204a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae08f13c7783c31438b74ee42364548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae08f13c7783c31438b74ee42364548"></a>
<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a1ae08f13c7783c31438b74ee42364548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1180ca405a5aa8686f8f828856d09091"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1180ca405a5aa8686f8f828856d09091"></a>
<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a1180ca405a5aa8686f8f828856d09091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c477dbfb1a9e1cfed18c39ee73c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07c477dbfb1a9e1cfed18c39ee73c8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#ac07c477dbfb1a9e1cfed18c39ee73c8a">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ac07c477dbfb1a9e1cfed18c39ee73c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the binary tree is not empty. <br/></td></tr>
<tr class="separator:ac07c477dbfb1a9e1cfed18c39ee73c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101cd0211605357a4fa37a902bf8a040"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a101cd0211605357a4fa37a902bf8a040"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a101cd0211605357a4fa37a902bf8a040">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a101cd0211605357a4fa37a902bf8a040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the binary tree empty? <br/></td></tr>
<tr class="separator:a101cd0211605357a4fa37a902bf8a040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4942ce532ca6056cb01d4d5fcfe34bca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4942ce532ca6056cb01d4d5fcfe34bca"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a4942ce532ca6056cb01d4d5fcfe34bca">size</a> () const noexcept</td></tr>
<tr class="memdesc:a4942ce532ca6056cb01d4d5fcfe34bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the binary tree size. <br/></td></tr>
<tr class="separator:a4942ce532ca6056cb01d4d5fcfe34bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf01ad343cdd28b0ad4e0f6d39720e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cf01ad343cdd28b0ad4e0f6d39720e0"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a1cf01ad343cdd28b0ad4e0f6d39720e0">root</a> () noexcept</td></tr>
<tr class="memdesc:a1cf01ad343cdd28b0ad4e0f6d39720e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root binary tree item. <br/></td></tr>
<tr class="separator:a1cf01ad343cdd28b0ad4e0f6d39720e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25340ebfa52ec10d6472f2d4ffd42f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25340ebfa52ec10d6472f2d4ffd42f6"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> () const noexcept</td></tr>
<tr class="separator:aa25340ebfa52ec10d6472f2d4ffd42f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad572d8586d6bcea479594db0c551a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ad572d8586d6bcea479594db0c551a2"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a2ad572d8586d6bcea479594db0c551a2">lowest</a> () noexcept</td></tr>
<tr class="memdesc:a2ad572d8586d6bcea479594db0c551a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest binary tree item. <br/></td></tr>
<tr class="separator:a2ad572d8586d6bcea479594db0c551a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60b1f621506dfaf24d1d8f288ef26f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d60b1f621506dfaf24d1d8f288ef26f"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>lowest</b> () const noexcept</td></tr>
<tr class="separator:a4d60b1f621506dfaf24d1d8f288ef26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aad4f07e7354b3197790b4960ebc68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23aad4f07e7354b3197790b4960ebc68"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a23aad4f07e7354b3197790b4960ebc68">highest</a> () noexcept</td></tr>
<tr class="memdesc:a23aad4f07e7354b3197790b4960ebc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest binary tree item. <br/></td></tr>
<tr class="separator:a23aad4f07e7354b3197790b4960ebc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28593fc1f8aba9278060cbb41f915fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28593fc1f8aba9278060cbb41f915fdb"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>highest</b> () const noexcept</td></tr>
<tr class="separator:a28593fc1f8aba9278060cbb41f915fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112d53f0960d46aeedd15d554e7e1b28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112d53f0960d46aeedd15d554e7e1b28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a112d53f0960d46aeedd15d554e7e1b28">compare</a> (const T &amp;item1, const T &amp;item2) const noexcept</td></tr>
<tr class="memdesc:a112d53f0960d46aeedd15d554e7e1b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two items: if the first item is less than the second one? <br/></td></tr>
<tr class="separator:a112d53f0960d46aeedd15d554e7e1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e782efee20e86f6866c73043a7a4e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41e782efee20e86f6866c73043a7a4e2"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a41e782efee20e86f6866c73043a7a4e2">begin</a> () noexcept</td></tr>
<tr class="memdesc:a41e782efee20e86f6866c73043a7a4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin binary tree iterator. <br/></td></tr>
<tr class="separator:a41e782efee20e86f6866c73043a7a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea5291035ebf306f44eddd9f1b5375b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ea5291035ebf306f44eddd9f1b5375b"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a4ea5291035ebf306f44eddd9f1b5375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae233c0f296698703b2d4c3558f49696a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae233c0f296698703b2d4c3558f49696a"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:ae233c0f296698703b2d4c3558f49696a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89c3600ee049dd94338f66d7bed2a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe89c3600ee049dd94338f66d7bed2a0"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#afe89c3600ee049dd94338f66d7bed2a0">end</a> () noexcept</td></tr>
<tr class="memdesc:afe89c3600ee049dd94338f66d7bed2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end binary tree iterator. <br/></td></tr>
<tr class="separator:afe89c3600ee049dd94338f66d7bed2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c22fd1d148e636a13b8d68b5f368f92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c22fd1d148e636a13b8d68b5f368f92"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a6c22fd1d148e636a13b8d68b5f368f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4098c9747216cd614f3fabc610dfc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d4098c9747216cd614f3fabc610dfc5"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a3d4098c9747216cd614f3fabc610dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2914783cc211c298a95f3eda9224462"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2914783cc211c298a95f3eda9224462"></a>
<a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#ad2914783cc211c298a95f3eda9224462">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ad2914783cc211c298a95f3eda9224462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse begin binary tree iterator. <br/></td></tr>
<tr class="separator:ad2914783cc211c298a95f3eda9224462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58256dd0aa6c368caec639dd4cf7fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae58256dd0aa6c368caec639dd4cf7fd3"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:ae58256dd0aa6c368caec639dd4cf7fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52736293f2cb7b9f0795d7b0cf0c972b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52736293f2cb7b9f0795d7b0cf0c972b"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:a52736293f2cb7b9f0795d7b0cf0c972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f78dea85ebe56b7f16139392268d84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f78dea85ebe56b7f16139392268d84"></a>
<a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#ab3f78dea85ebe56b7f16139392268d84">rend</a> () noexcept</td></tr>
<tr class="memdesc:ab3f78dea85ebe56b7f16139392268d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse end binary tree iterator. <br/></td></tr>
<tr class="separator:ab3f78dea85ebe56b7f16139392268d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae188c23722af5161fc6eeaa237e4038f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae188c23722af5161fc6eeaa237e4038f"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:ae188c23722af5161fc6eeaa237e4038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a9fd0bc6c8fa2b36bbf0fca1be0544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a9fd0bc6c8fa2b36bbf0fca1be0544"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a81a9fd0bc6c8fa2b36bbf0fca1be0544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c13547a6eae2abc32b46f268f23bbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c13547a6eae2abc32b46f268f23bbd"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#af0c13547a6eae2abc32b46f268f23bbd">find</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:af0c13547a6eae2abc32b46f268f23bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first equal item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:af0c13547a6eae2abc32b46f268f23bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d50e63af111000122d911502935b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97d50e63af111000122d911502935b1d"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:a97d50e63af111000122d911502935b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af7c893406fdf95f487731940f55bb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6af7c893406fdf95f487731940f55bb8"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a6af7c893406fdf95f487731940f55bb8">lower_bound</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a6af7c893406fdf95f487731940f55bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first item that not less than the given item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:a6af7c893406fdf95f487731940f55bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90165ff36ae4bb62e4f4b7bd1f2f7293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90165ff36ae4bb62e4f4b7bd1f2f7293"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_bound</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:a90165ff36ae4bb62e4f4b7bd1f2f7293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29b1f9731eeafb1495556fa9e0f4707"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29b1f9731eeafb1495556fa9e0f4707"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#ae29b1f9731eeafb1495556fa9e0f4707">upper_bound</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:ae29b1f9731eeafb1495556fa9e0f4707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first item that greater than the given item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:ae29b1f9731eeafb1495556fa9e0f4707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf51b9b58bcc7db937026f2a638be7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf51b9b58bcc7db937026f2a638be7c"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upper_bound</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:acaf51b9b58bcc7db937026f2a638be7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5230cd6f87bc1bc711b07b80d56f8c62"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a5230cd6f87bc1bc711b07b80d56f8c62">insert</a> (T &amp;item) noexcept</td></tr>
<tr class="memdesc:a5230cd6f87bc1bc711b07b80d56f8c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the binary tree.  <a href="#a5230cd6f87bc1bc711b07b80d56f8c62">More...</a><br/></td></tr>
<tr class="separator:a5230cd6f87bc1bc711b07b80d56f8c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57bccfd701546201f4564b282b5a897"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#aa57bccfd701546201f4564b282b5a897">insert</a> (const <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a> &amp;position, T &amp;item) noexcept</td></tr>
<tr class="memdesc:aa57bccfd701546201f4564b282b5a897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the binary tree with a position hint.  <a href="#aa57bccfd701546201f4564b282b5a897">More...</a><br/></td></tr>
<tr class="separator:aa57bccfd701546201f4564b282b5a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af190b40446a0c7b42ed9abfe3b117ed1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#af190b40446a0c7b42ed9abfe3b117ed1">erase</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:af190b40446a0c7b42ed9abfe3b117ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the given item from the binary tree.  <a href="#af190b40446a0c7b42ed9abfe3b117ed1">More...</a><br/></td></tr>
<tr class="separator:af190b40446a0c7b42ed9abfe3b117ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b9fdd33ae603efae51e0b2d45bfddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#ac3b9fdd33ae603efae51e0b2d45bfddf">erase</a> (const <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> &amp;it) noexcept</td></tr>
<tr class="memdesc:ac3b9fdd33ae603efae51e0b2d45bfddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the given item from the binary tree.  <a href="#ac3b9fdd33ae603efae51e0b2d45bfddf">More...</a><br/></td></tr>
<tr class="separator:ac3b9fdd33ae603efae51e0b2d45bfddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37409db2c295448bf7bed9aac03ad617"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37409db2c295448bf7bed9aac03ad617"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a37409db2c295448bf7bed9aac03ad617">clear</a> () noexcept</td></tr>
<tr class="memdesc:a37409db2c295448bf7bed9aac03ad617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the binary tree. <br/></td></tr>
<tr class="separator:a37409db2c295448bf7bed9aac03ad617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e8a8c9cbad09950b32f96f957cb2d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e8a8c9cbad09950b32f96f957cb2d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html#a94e8a8c9cbad09950b32f96f957cb2d2">swap</a> (<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a> &amp;bintree) noexcept</td></tr>
<tr class="memdesc:a94e8a8c9cbad09950b32f96f957cb2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two instances. <br/></td></tr>
<tr class="separator:a94e8a8c9cbad09950b32f96f957cb2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad14a85e540cec6eb3cf102bcb8f22691"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad14a85e540cec6eb3cf102bcb8f22691"></a>
template&lt;typename U , typename UCompare &gt; </td></tr>
<tr class="memitem:ad14a85e540cec6eb3cf102bcb8f22691"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; U, UCompare &gt; &amp;bintree1, <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; U, UCompare &gt; &amp;bintree2) noexcept</td></tr>
<tr class="separator:ad14a85e540cec6eb3cf102bcb8f22691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename TCompare = std::less&lt;T&gt;&gt;<br/>
class XT::BinTreeAVL&lt; T, TCompare &gt;</h3>

<p>Intrusive balanced AVL binary tree container. </p>
<p>Not thread-safe.</p>
<p><b>Overview</b><br/>
In computer science, an AVL tree is a self-balancing binary search tree, and the first such data structure to be invented. In an AVL tree the heights of the two child subtrees of any node differ by at most one, therefore it is also called height-balanced. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases. Additions and deletions may require the tree to be rebalanced by one or more tree rotations.</p>
<p>The AVL tree is named after its two inventors, G.M. Adelson-Velsky and E.M. Landis, who published it in their 1962 paper "An  algorithm  for  the
organization of information."</p>
<p>The balance factor of a node is the height of its right subtree minus the height of its left subtree. A node with balance factor 1, 0, or -1 is considered balanced. A node with any other balance factor is considered unbalanced and requires rebalancing the tree. The balance factor is either stored directly at each node or computed from the heights of the subtrees.</p>
<p>While AVL trees are theoretically quite sound, they are not commonly implemented due to their high implementation complexity to keep it balanced, making development less effective when compared to self- correcting tree structures, such as splay trees or heaps. They do, however, perform better than e.g. red-black trees. They are widely used in academic settings as an instructional data structure.</p>
<p><b>Operations</b><br/>
The basic operations of an AVL tree generally involve carrying out the same algorithms as would be carried out on an unbalanced binary search tree, but preceded or followed by one or more of the so-called "AVL
rotations."</p>
<p><b>Insertion</b><br/>
Insertion into an AVL tree may be carried out by inserting the given value into the tree as if it were an unbalanced binary search tree, and then retracing one's steps toward the root, rotating about any nodes which have become unbalanced during the insertion (see tree rotation). Since at most 1.5 times lg n nodes are retraced on the journey back to the root, and each AVL rotation takes constant time, the insertion process in total takes O(log n) time.</p>
<p><b>Deletion</b><br/>
Deletion from an AVL tree may be carried out by rotating the node to be deleted down into a leaf node, and then pruning off that leaf node directly. Since at most log n nodes are rotated during the rotation into the leaf, and each AVL rotation takes constant time, the deletion process in total takes O(log n) time.</p>
<p>Practically, this is a large overhead and complex to program. Therefore, it's more common to implement a lazy deletion &ndash; leave the deletion target in place, flag it as "deleted", and replace it with an inserted node if they would occupy the same spot.</p>
<p><b>Lookup</b><br/>
Lookup in an AVL tree is performed exactly as in an unbalanced binary search tree, and thus takes O(log n) time, since an AVL tree is always kept balanced. No special provisions need to be taken, and the tree's structure is not modified by lookups. (This is in contrast to splay tree lookups, which do modify their tree's structure.)</p>
<p><b>Usage</b><br/>
AVL trees are faster than Red-Black trees when lookups are more frequent than inserts/deletes and comparisons are expensive.</p>
<p><b>References</b><br/>
</p>
<ul>
<li>G. Adelson-Velskii and E.M. Landis, "An algorithm for the organization
    of  information." Doklady Akademii Nauk SSSR, 146:263-266, 1962 (Russian). English translation by Myron J. Ricci in Soviet Math. Doklady, 3:1259-1263, 1962. </li>
<li>Donald Knuth. The Art of Computer Programming, Volume 3: Sorting and Searching, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Pages 458-475 of section 6.2.3: Balanced Trees. Note that Knuth calls AVL trees simply "balanced trees".</li>
</ul>
<p><b>Taken from:</b><br/>
AVL tree from Wikipedia, the free encyclopedia <a href="http://en.wikipedia.org/wiki/AVL_tree">http://en.wikipedia.org/wiki/AVL_tree</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af190b40446a0c7b42ed9abfe3b117ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">XT::BinTreeAVL</a>&lt; T, TCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the given item from the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erased item </dd></dl>

</div>
</div>
<a class="anchor" id="ac3b9fdd33ae603efae51e0b2d45bfddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">XT::BinTreeAVL</a>&lt; T, TCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the given item from the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- Iterator to the erased item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erased item iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a5230cd6f87bc1bc711b07b80d56f8c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">XT::BinTreeAVL</a>&lt; T, TCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the inserted item and success flag </dd></dl>

</div>
</div>
<a class="anchor" id="aa57bccfd701546201f4564b282b5a897"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">BinTreeAVL</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_bin_tree_a_v_l.html">XT::BinTreeAVL</a>&lt; T, TCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the binary tree with a position hint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- Iterator position to the inserted item </td></tr>
    <tr><td class="paramname">item</td><td>- Item to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the inserted item and success flag </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/xtcommon/xtcontainer/<a class="el" href="_x_t_bin_tree_a_v_l_8h_source.html">XTBinTreeAVL.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 13 2021 01:11:41 for xtcommon by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
