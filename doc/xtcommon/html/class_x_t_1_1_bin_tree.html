<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xtcommon: XT::BinTree&lt; T, TCompare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xtcommon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>XT</b></li><li class="navelem"><a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_x_t_1_1_bin_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XT::BinTree&lt; T, TCompare &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive non balanced binary tree container.  
 <a href="class_x_t_1_1_bin_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x_t_bin_tree_8h_source.html">XTBinTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_t_1_1_bin_tree_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary tree node.  <a href="struct_x_t_1_1_bin_tree_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03e235270852f1031aa69b3f96116629"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03e235270852f1031aa69b3f96116629"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a03e235270852f1031aa69b3f96116629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193e49c682cd7e3c9cf153b9d01460dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193e49c682cd7e3c9cf153b9d01460dd"></a>
typedef TCompare&#160;</td><td class="memItemRight" valign="bottom"><b>value_compare</b></td></tr>
<tr class="separator:a193e49c682cd7e3c9cf153b9d01460dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d666afb4f564edeaa130a07eb54ee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d666afb4f564edeaa130a07eb54ee8"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a56d666afb4f564edeaa130a07eb54ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f1d28dcc7c964037fd3c910b4347c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a907f1d28dcc7c964037fd3c910b4347c"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a907f1d28dcc7c964037fd3c910b4347c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d310a668f807de9c739ee05a20858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea4d310a668f807de9c739ee05a20858"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:aea4d310a668f807de9c739ee05a20858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625a762c33a89c5e00f834aa51a97563"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a625a762c33a89c5e00f834aa51a97563"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a625a762c33a89c5e00f834aa51a97563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39295751659f3b4f728c6e751d4fe8c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39295751659f3b4f728c6e751d4fe8c8"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a39295751659f3b4f728c6e751d4fe8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa88cb46a860886a736c825a2b531cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aa88cb46a860886a736c825a2b531cd"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a2aa88cb46a860886a736c825a2b531cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836652db4a21f1de555eaf425d8c0c77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836652db4a21f1de555eaf425d8c0c77"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">BinTreeIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a836652db4a21f1de555eaf425d8c0c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08645228d08555d763f677683c06b4b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08645228d08555d763f677683c06b4b0"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">BinTreeConstIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a08645228d08555d763f677683c06b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69991b9158206099900d52d01df9eb7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69991b9158206099900d52d01df9eb7b"></a>
typedef <a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">BinTreeReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a69991b9158206099900d52d01df9eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15c361c4f9dd005cbb5ffcefb07c67a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab15c361c4f9dd005cbb5ffcefb07c67a"></a>
typedef <br class="typebreak"/>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">BinTreeConstReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:ab15c361c4f9dd005cbb5ffcefb07c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66b319fc735e53942346b4e4a04c3640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66b319fc735e53942346b4e4a04c3640"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTree</b> (const TCompare &amp;<a class="el" href="class_x_t_1_1_bin_tree.html#a54f0bc1e4879988e166f72d2665871f1">compare</a>=TCompare()) noexcept</td></tr>
<tr class="separator:a66b319fc735e53942346b4e4a04c3640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b4a6afd07b015bd6bf80930fcfccd8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7b4a6afd07b015bd6bf80930fcfccd8"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ab7b4a6afd07b015bd6bf80930fcfccd8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BinTree</b> (InputIterator first, InputIterator last, const TCompare &amp;<a class="el" href="class_x_t_1_1_bin_tree.html#a54f0bc1e4879988e166f72d2665871f1">compare</a>=TCompare()) noexcept</td></tr>
<tr class="separator:ab7b4a6afd07b015bd6bf80930fcfccd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5379828a39d9069f8966d9c571e5e26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5379828a39d9069f8966d9c571e5e26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTree</b> (const <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;) noexcept=default</td></tr>
<tr class="separator:ae5379828a39d9069f8966d9c571e5e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d152dd783d1c9ebf010352065aa1f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16d152dd783d1c9ebf010352065aa1f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinTree</b> (<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a16d152dd783d1c9ebf010352065aa1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3c7a763fda909cceb8465e2dc77f68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f3c7a763fda909cceb8465e2dc77f68"></a>
<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a9f3c7a763fda909cceb8465e2dc77f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0986b4d8f467dcdf579c0343e7ac54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e0986b4d8f467dcdf579c0343e7ac54"></a>
<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a1e0986b4d8f467dcdf579c0343e7ac54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175be9e7d61732417fc475444bc7222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5175be9e7d61732417fc475444bc7222"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a5175be9e7d61732417fc475444bc7222">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a5175be9e7d61732417fc475444bc7222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the binary tree is not empty. <br/></td></tr>
<tr class="separator:a5175be9e7d61732417fc475444bc7222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c729189293190177ad81352d8a42aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c729189293190177ad81352d8a42aa0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a1c729189293190177ad81352d8a42aa0">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a1c729189293190177ad81352d8a42aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the binary tree empty? <br/></td></tr>
<tr class="separator:a1c729189293190177ad81352d8a42aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb39a1edec30316cefc7da3b6a59405"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cb39a1edec30316cefc7da3b6a59405"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a0cb39a1edec30316cefc7da3b6a59405">size</a> () const noexcept</td></tr>
<tr class="memdesc:a0cb39a1edec30316cefc7da3b6a59405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the binary tree size. <br/></td></tr>
<tr class="separator:a0cb39a1edec30316cefc7da3b6a59405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3649b0711ca01be14563565fbf736458"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3649b0711ca01be14563565fbf736458"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a3649b0711ca01be14563565fbf736458">root</a> () noexcept</td></tr>
<tr class="memdesc:a3649b0711ca01be14563565fbf736458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root binary tree item. <br/></td></tr>
<tr class="separator:a3649b0711ca01be14563565fbf736458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20ba8d0a53c6225dc665ec2f5688880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20ba8d0a53c6225dc665ec2f5688880"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> () const noexcept</td></tr>
<tr class="separator:ac20ba8d0a53c6225dc665ec2f5688880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f64b9955d1da1e8716095c771b1528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f64b9955d1da1e8716095c771b1528"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a50f64b9955d1da1e8716095c771b1528">lowest</a> () noexcept</td></tr>
<tr class="memdesc:a50f64b9955d1da1e8716095c771b1528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest binary tree item. <br/></td></tr>
<tr class="separator:a50f64b9955d1da1e8716095c771b1528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab586cc507b0ba9ec9ab4d51fb38f067b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab586cc507b0ba9ec9ab4d51fb38f067b"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>lowest</b> () const noexcept</td></tr>
<tr class="separator:ab586cc507b0ba9ec9ab4d51fb38f067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4112de3cdf7640f456292899e709632e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4112de3cdf7640f456292899e709632e"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a4112de3cdf7640f456292899e709632e">highest</a> () noexcept</td></tr>
<tr class="memdesc:a4112de3cdf7640f456292899e709632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest binary tree item. <br/></td></tr>
<tr class="separator:a4112de3cdf7640f456292899e709632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717547fb33b543d25435a624bf9eb345"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717547fb33b543d25435a624bf9eb345"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>highest</b> () const noexcept</td></tr>
<tr class="separator:a717547fb33b543d25435a624bf9eb345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f0bc1e4879988e166f72d2665871f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f0bc1e4879988e166f72d2665871f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a54f0bc1e4879988e166f72d2665871f1">compare</a> (const T &amp;item1, const T &amp;item2) const noexcept</td></tr>
<tr class="memdesc:a54f0bc1e4879988e166f72d2665871f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two items: if the first item is less than the second one? <br/></td></tr>
<tr class="separator:a54f0bc1e4879988e166f72d2665871f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45cb0851ff3dfb7a29289b7674da6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad45cb0851ff3dfb7a29289b7674da6ea"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#ad45cb0851ff3dfb7a29289b7674da6ea">begin</a> () noexcept</td></tr>
<tr class="memdesc:ad45cb0851ff3dfb7a29289b7674da6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin binary tree iterator. <br/></td></tr>
<tr class="separator:ad45cb0851ff3dfb7a29289b7674da6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c2901cec380076b07d0e798c527f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12c2901cec380076b07d0e798c527f71"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a12c2901cec380076b07d0e798c527f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a87bad4504b7c2813bd1f35eceef6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a87bad4504b7c2813bd1f35eceef6a"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a05a87bad4504b7c2813bd1f35eceef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713c528ea2c3e9594e3231ae1d1dad20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a713c528ea2c3e9594e3231ae1d1dad20"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a713c528ea2c3e9594e3231ae1d1dad20">end</a> () noexcept</td></tr>
<tr class="memdesc:a713c528ea2c3e9594e3231ae1d1dad20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end binary tree iterator. <br/></td></tr>
<tr class="separator:a713c528ea2c3e9594e3231ae1d1dad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ff106e7fc4d045a390d72418c0438b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ff106e7fc4d045a390d72418c0438b"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:ae3ff106e7fc4d045a390d72418c0438b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c93ffcbeb3809638a1a89e81c6da718"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c93ffcbeb3809638a1a89e81c6da718"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a4c93ffcbeb3809638a1a89e81c6da718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bdd268d103c0150ac3b685a9a1755c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bdd268d103c0150ac3b685a9a1755c"></a>
<a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a01bdd268d103c0150ac3b685a9a1755c">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a01bdd268d103c0150ac3b685a9a1755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse begin binary tree iterator. <br/></td></tr>
<tr class="separator:a01bdd268d103c0150ac3b685a9a1755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6313b6286c00c622d77af346ed7196bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6313b6286c00c622d77af346ed7196bd"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a6313b6286c00c622d77af346ed7196bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde5c1ec54113ec6c773e160e5f3400a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde5c1ec54113ec6c773e160e5f3400a"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:adde5c1ec54113ec6c773e160e5f3400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac58e759be5b798045c16a599513c928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac58e759be5b798045c16a599513c928"></a>
<a class="el" href="class_x_t_1_1_bin_tree_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#aac58e759be5b798045c16a599513c928">rend</a> () noexcept</td></tr>
<tr class="memdesc:aac58e759be5b798045c16a599513c928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse end binary tree iterator. <br/></td></tr>
<tr class="separator:aac58e759be5b798045c16a599513c928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd026e55434b70805619c087f242fa21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd026e55434b70805619c087f242fa21"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:afd026e55434b70805619c087f242fa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a17a63fcee3986565379c0563fa5a13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a17a63fcee3986565379c0563fa5a13"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:a7a17a63fcee3986565379c0563fa5a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b72f429a442d421bd20dc4b93e7c891"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b72f429a442d421bd20dc4b93e7c891"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a2b72f429a442d421bd20dc4b93e7c891">find</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a2b72f429a442d421bd20dc4b93e7c891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first equal item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:a2b72f429a442d421bd20dc4b93e7c891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1809c11bfc0c3028fee8682160fefa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1809c11bfc0c3028fee8682160fefa5"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:ab1809c11bfc0c3028fee8682160fefa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd796b73855a8e6cc7f3586b3428f2d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd796b73855a8e6cc7f3586b3428f2d2"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#acd796b73855a8e6cc7f3586b3428f2d2">lower_bound</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:acd796b73855a8e6cc7f3586b3428f2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first item that not less than the given item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:acd796b73855a8e6cc7f3586b3428f2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c2f3db6dcd8bec8a193cacfb35e848"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61c2f3db6dcd8bec8a193cacfb35e848"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_bound</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:a61c2f3db6dcd8bec8a193cacfb35e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35821b4df1475bbb5d6d2d3629560c51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35821b4df1475bbb5d6d2d3629560c51"></a>
<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a35821b4df1475bbb5d6d2d3629560c51">upper_bound</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a35821b4df1475bbb5d6d2d3629560c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first item that greater than the given item in the binary tree or return end iterator. <br/></td></tr>
<tr class="separator:a35821b4df1475bbb5d6d2d3629560c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7f7274b2f2457bff9bbe85916f6f9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a7f7274b2f2457bff9bbe85916f6f9c"></a>
<a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upper_bound</b> (const T &amp;item) const noexcept</td></tr>
<tr class="separator:a3a7f7274b2f2457bff9bbe85916f6f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4d239a298b1357905569d4cb1a980"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a2de4d239a298b1357905569d4cb1a980">insert</a> (T &amp;item) noexcept</td></tr>
<tr class="memdesc:a2de4d239a298b1357905569d4cb1a980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the binary tree.  <a href="#a2de4d239a298b1357905569d4cb1a980">More...</a><br/></td></tr>
<tr class="separator:a2de4d239a298b1357905569d4cb1a980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ec38c2511dae614aef7b9e4afbc270"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a66ec38c2511dae614aef7b9e4afbc270">insert</a> (const <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a> &amp;position, T &amp;item) noexcept</td></tr>
<tr class="memdesc:a66ec38c2511dae614aef7b9e4afbc270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the binary tree with a position hint.  <a href="#a66ec38c2511dae614aef7b9e4afbc270">More...</a><br/></td></tr>
<tr class="separator:a66ec38c2511dae614aef7b9e4afbc270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be9ceb964d03ea66eaa03a6849784b9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a4be9ceb964d03ea66eaa03a6849784b9">erase</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a4be9ceb964d03ea66eaa03a6849784b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the given item from the binary tree.  <a href="#a4be9ceb964d03ea66eaa03a6849784b9">More...</a><br/></td></tr>
<tr class="separator:a4be9ceb964d03ea66eaa03a6849784b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893439a1fba35bdd470e09553c11a274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a893439a1fba35bdd470e09553c11a274">erase</a> (const <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> &amp;it) noexcept</td></tr>
<tr class="memdesc:a893439a1fba35bdd470e09553c11a274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the given item from the binary tree.  <a href="#a893439a1fba35bdd470e09553c11a274">More...</a><br/></td></tr>
<tr class="separator:a893439a1fba35bdd470e09553c11a274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be41721f5d4280c62662326b12b5010"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1be41721f5d4280c62662326b12b5010"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#a1be41721f5d4280c62662326b12b5010">clear</a> () noexcept</td></tr>
<tr class="memdesc:a1be41721f5d4280c62662326b12b5010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the binary tree. <br/></td></tr>
<tr class="separator:a1be41721f5d4280c62662326b12b5010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add29801ef2b1cf9b90520666d98f95da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add29801ef2b1cf9b90520666d98f95da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_bin_tree.html#add29801ef2b1cf9b90520666d98f95da">swap</a> (<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a> &amp;bintree) noexcept</td></tr>
<tr class="memdesc:add29801ef2b1cf9b90520666d98f95da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two instances. <br/></td></tr>
<tr class="separator:add29801ef2b1cf9b90520666d98f95da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af470b886275d28d148b5b834c237f9d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="af470b886275d28d148b5b834c237f9d7"></a>
template&lt;typename U , typename UCompare &gt; </td></tr>
<tr class="memitem:af470b886275d28d148b5b834c237f9d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; U, UCompare &gt; &amp;bintree1, <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; U, UCompare &gt; &amp;bintree2) noexcept</td></tr>
<tr class="separator:af470b886275d28d148b5b834c237f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename TCompare = std::less&lt;T&gt;&gt;<br/>
class XT::BinTree&lt; T, TCompare &gt;</h3>

<p>Intrusive non balanced binary tree container. </p>
<p>Binary trees are the good structures for associative searching. They keep items in sort order, so each of item can be found in a short time.</p>
<p>Not thread-safe.</p>
<p><b>Overview</b><br/>
In computer science, a binary search tree (BST) is a binary tree which has the following properties: </p>
<ul>
<li>Each node has a value. </li>
<li>A total order is defined on these values. </li>
<li>The left subtree of a node contains only values less than or equal to the node's value. </li>
<li>The right subtree of a node contains only values greater than or equal to the node's value.</li>
</ul>
<div class="image">
<img src="BinTree.png" alt="BinTree.png"/>
<div class="caption">
Binary tree</div></div>
<p>The major advantage of binary search trees is that the related sorting algorithms and search algorithms such as in-order traversal can be very efficient.</p>
<p>Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays.</p>
<p>If a BST allows duplicate values, then it represents a multiset. This kind of tree uses non-strict inequalities. Everything in the left subtree of a node is strictly less than the value of the node, but everything in the right subtree is either greater than or equal to the value of the node.</p>
<p>If a BST does not allow duplicate values, then the tree represents a set with unique values, like the mathematical set. Trees without duplicate values use strict inequalities, meaning that the left subtree of a node only contains nodes with values that are less than the value of the node, and the right subtree only contains values that are greater.</p>
<p>The choice of storing equal values in the right subtree only is arbitrary; the left would work just as well. One can also permit non-strict equality in both sides. This allows a tree containing many duplicate values to be balanced better, but it makes searching more complex.</p>
<p>Most operations on a binary search tree take time directly proportional to the tree's height, so it is desirable to keep the height small. Ordinary binary search trees have the primary disadvantage that they can attain very large heights in rather ordinary situations, such as when the keys are inserted in order. The result is a data structure similar to a linked list, making all operations on the tree expensive. If we know all the data ahead of time, we can keep the height small on average by adding values in a random order, but we do not always have this luxury, particularly in online algorithms.</p>
<p>Self-balancing binary trees solve this problem by performing transformations on the tree (such as tree rotations) at key times, in order to reduce the height. Although a certain overhead is involved, it is justified in the long run by drastically decreasing the time of later operations.</p>
<p>The height must always be at least the ceiling of log n, since there are at most 2k nodes on the kth level; a complete or full binary tree has exactly this many levels. Balanced BSTs are not always so precisely balanced, since it can be expensive to keep a tree at minimum height at all times; instead, they keep the height within a constant factor of this lower bound.</p>
<p>Times for various operations in terms of number of nodes in the tree n: </p>
<ul>
<li>Lookup - O(log n) </li>
<li>Insertion - O(log n) </li>
<li>Removal - O(log n) </li>
<li>In-order iteration over all elements - O(n)</li>
</ul>
<p>For some implementations these times are worst-case, while for others they are amortized.</p>
<p><b>Applications</b><br/>
Self-balancing binary search trees can be used in a natural way to construct associative arrays; key-value pairs are simply inserted with an ordering based on the key alone. In this capacity, self-balancing BSTs have a number of advantages and disadvantages over their main competitor, hash tables. Lookup is somewhat complicated in the case where the same key can be used multiple times.</p>
<p>Many algorithms can exploit self-balancing BSTs to achieve good worst- case bounds with very little effort. For example, if binary tree sort is done with a BST, we have a very simple-to-describe yet asymptotically optimal O(n log n) sorting algorithm (although such an algorithm has practical disadvantages due to bad cache behavior). Similarly, many algorithms in computational geometry exploit variations on self- balancing BSTs to solve problems such as the line segment intersection problem and the point location problem efficiently.</p>
<p>Self-balancing BSTs are a flexible data structure, in that it's easy to extend them to efficiently record additional information or perform new operations. For example, one can record the number of nodes in each subtree having a certain property, allowing one to count the number of nodes in a certain key range with that property in O(log  n) time. These extensions can be used, for example, to optimize database queries or other list-processing algorithms.</p>
<p><b>References</b><br/>
</p>
<ul>
<li>Donald Knuth. The Art of Computer Programming, Volume 3: Sorting and Searching, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 6.2.3: Balanced Trees, pp.458-481.</li>
</ul>
<p><b>Taken from:</b><br/>
Binary search tree from Wikipedia, the free encyclopedia <a href="http://en.wikipedia.org/wiki/Binary_search_tree">http://en.wikipedia.org/wiki/Binary_search_tree</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4be9ceb964d03ea66eaa03a6849784b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_x_t_1_1_bin_tree.html">XT::BinTree</a>&lt; T, TCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the given item from the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erased item </dd></dl>

</div>
</div>
<a class="anchor" id="a893439a1fba35bdd470e09553c11a274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> <a class="el" href="class_x_t_1_1_bin_tree.html">XT::BinTree</a>&lt; T, TCompare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the given item from the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>- Iterator to the erased item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erased item iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a2de4d239a298b1357905569d4cb1a980"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_bin_tree.html">XT::BinTree</a>&lt; T, TCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the binary tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the inserted item and success flag </dd></dl>

</div>
</div>
<a class="anchor" id="a66ec38c2511dae614aef7b9e4afbc270"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_bin_tree.html">BinTree</a>&lt; T, TCompare &gt;::<a class="el" href="class_x_t_1_1_bin_tree_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_bin_tree.html">XT::BinTree</a>&lt; T, TCompare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_t_1_1_bin_tree_const_iterator.html">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the binary tree with a position hint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- Iterator position to the inserted item </td></tr>
    <tr><td class="paramname">item</td><td>- Item to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the inserted item and success flag </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/xtcommon/xtcontainer/<a class="el" href="_x_t_bin_tree_8h_source.html">XTBinTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 13 2021 01:11:40 for xtcommon by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
