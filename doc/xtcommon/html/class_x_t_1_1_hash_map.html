<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xtcommon: XT::HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xtcommon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>XT</b></li><li class="navelem"><a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_x_t_1_1_hash_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XT::HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash map container.  
 <a href="class_x_t_1_1_hash_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x_t_hash_map_8h_source.html">XTHashMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4a85442b63e6a07c1ad7dba335772696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a85442b63e6a07c1ad7dba335772696"></a>
typedef TKey&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a4a85442b63e6a07c1ad7dba335772696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053479672bc18c7286b3c38ae79cb1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6053479672bc18c7286b3c38ae79cb1d"></a>
typedef TValue&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr class="separator:a6053479672bc18c7286b3c38ae79cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d8a4b2a2c90f00d652bc1fd10bf293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07d8a4b2a2c90f00d652bc1fd10bf293"></a>
typedef std::pair&lt; TKey, TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a07d8a4b2a2c90f00d652bc1fd10bf293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa132e9aabc643b52d2527cdbfec802e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa132e9aabc643b52d2527cdbfec802e9"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:aa132e9aabc643b52d2527cdbfec802e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5fefe855eab8fa4120bfb8df8574f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5fefe855eab8fa4120bfb8df8574f5"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a0f5fefe855eab8fa4120bfb8df8574f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0d345db7525b4ed2312a46d8246ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0d345db7525b4ed2312a46d8246ced"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a8e0d345db7525b4ed2312a46d8246ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac751826024bba5ab65ed2f18549e6103"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac751826024bba5ab65ed2f18549e6103"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:ac751826024bba5ab65ed2f18549e6103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e94192c4f6290db715022195ca9c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f8e94192c4f6290db715022195ca9c1"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a0f8e94192c4f6290db715022195ca9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dc4c858ece4abd5b35249ba3d119c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33dc4c858ece4abd5b35249ba3d119c6"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a33dc4c858ece4abd5b35249ba3d119c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf333c19842399a0364112940e96b90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cf333c19842399a0364112940e96b90"></a>
typedef <a class="el" href="class_x_t_1_1_hash_map_iterator.html">HashMapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, <br class="typebreak"/>
TEqual, TAllocator &gt;, TKey, <br class="typebreak"/>
TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a5cf333c19842399a0364112940e96b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120edac78074d01263d44c727221104b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120edac78074d01263d44c727221104b"></a>
typedef <a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">HashMapConstIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, <br class="typebreak"/>
TEqual, TAllocator &gt;, TKey, <br class="typebreak"/>
TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a120edac78074d01263d44c727221104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891f1fef841a8566b425e587dbfb27c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3891f1fef841a8566b425e587dbfb27c"></a>
typedef <a class="el" href="class_x_t_1_1_hash_map_reverse_iterator.html">HashMapReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, <br class="typebreak"/>
TEqual, TAllocator &gt;, TKey, <br class="typebreak"/>
TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a3891f1fef841a8566b425e587dbfb27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73adb9c45d6a4a042958efa01116159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73adb9c45d6a4a042958efa01116159"></a>
typedef <br class="typebreak"/>
<a class="el" href="class_x_t_1_1_hash_map_const_reverse_iterator.html">HashMapConstReverseIterator</a><br class="typebreak"/>
&lt; <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, <br class="typebreak"/>
TEqual, TAllocator &gt;, TKey, <br class="typebreak"/>
TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:aa73adb9c45d6a4a042958efa01116159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47a7869a515c91f58c9d91c00e7409ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a47a7869a515c91f58c9d91c00e7409ec">HashMap</a> (size_t capacity=128, const TKey &amp;blank=TKey(), const THash &amp;hash=THash(), const TEqual &amp;equal=TEqual(), const TAllocator &amp;allocator=TAllocator())</td></tr>
<tr class="memdesc:a47a7869a515c91f58c9d91c00e7409ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the hash map with a given capacity and blank key value.  <a href="#a47a7869a515c91f58c9d91c00e7409ec">More...</a><br/></td></tr>
<tr class="separator:a47a7869a515c91f58c9d91c00e7409ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f1286700e40ced4bff9beb4e5fad0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a839f1286700e40ced4bff9beb4e5fad0"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a839f1286700e40ced4bff9beb4e5fad0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HashMap</b> (InputIterator first, InputIterator last, bool unused, size_t capacity=128, const TKey &amp;blank=TKey(), const THash &amp;hash=THash(), const TEqual &amp;equal=TEqual(), const TAllocator &amp;allocator=TAllocator())</td></tr>
<tr class="separator:a839f1286700e40ced4bff9beb4e5fad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b018513268579e627eba00283decb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3b018513268579e627eba00283decb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HashMap</b> (const <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;hashmap)</td></tr>
<tr class="separator:af3b018513268579e627eba00283decb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4b86e905999f2f0b64ed7835997b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c4b86e905999f2f0b64ed7835997b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HashMap</b> (const <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;hashmap, size_t capacity)</td></tr>
<tr class="separator:a50c4b86e905999f2f0b64ed7835997b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194aa5b4c7e26ffc4c85c72bfab5aa61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194aa5b4c7e26ffc4c85c72bfab5aa61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HashMap</b> (<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a194aa5b4c7e26ffc4c85c72bfab5aa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980e4afa7a30f86aed7771048538d61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7980e4afa7a30f86aed7771048538d61"></a>
<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;hashmap)</td></tr>
<tr class="separator:a7980e4afa7a30f86aed7771048538d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fda63c6884db93eceec50bff48fc1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5fda63c6884db93eceec50bff48fc1d"></a>
<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa5fda63c6884db93eceec50bff48fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1176a03738d83d8bef9d310b4ce4b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe1176a03738d83d8bef9d310b4ce4b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#abe1176a03738d83d8bef9d310b4ce4b0">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:abe1176a03738d83d8bef9d310b4ce4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hash map is not empty. <br/></td></tr>
<tr class="separator:abe1176a03738d83d8bef9d310b4ce4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749754ba833268d46e71082bb86bff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad749754ba833268d46e71082bb86bff7"></a>
mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ad749754ba833268d46e71082bb86bff7">operator[]</a> (const TKey &amp;key)</td></tr>
<tr class="memdesc:ad749754ba833268d46e71082bb86bff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the item with the given key or insert a new one. <br/></td></tr>
<tr class="separator:ad749754ba833268d46e71082bb86bff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561e1cc5754ea27670b66fac8aa9c031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a561e1cc5754ea27670b66fac8aa9c031"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a561e1cc5754ea27670b66fac8aa9c031">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a561e1cc5754ea27670b66fac8aa9c031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the hash map empty? <br/></td></tr>
<tr class="separator:a561e1cc5754ea27670b66fac8aa9c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e466817be2d38799974b5b5df17bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e466817be2d38799974b5b5df17bb2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a45e466817be2d38799974b5b5df17bb2">size</a> () const noexcept</td></tr>
<tr class="memdesc:a45e466817be2d38799974b5b5df17bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash map size. <br/></td></tr>
<tr class="separator:a45e466817be2d38799974b5b5df17bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570f5f05486509a281d8bc28f3ab3796"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570f5f05486509a281d8bc28f3ab3796"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a570f5f05486509a281d8bc28f3ab3796">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a570f5f05486509a281d8bc28f3ab3796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash map maximum size. <br/></td></tr>
<tr class="separator:a570f5f05486509a281d8bc28f3ab3796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ca490e57f6c90d5a209064184917af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ca490e57f6c90d5a209064184917af"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ac8ca490e57f6c90d5a209064184917af">bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:ac8ca490e57f6c90d5a209064184917af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash map bucket count. <br/></td></tr>
<tr class="separator:ac8ca490e57f6c90d5a209064184917af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13640ee401f0c75c4a5dafd3d3530755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13640ee401f0c75c4a5dafd3d3530755"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a13640ee401f0c75c4a5dafd3d3530755">max_bucket_count</a> () const noexcept</td></tr>
<tr class="memdesc:a13640ee401f0c75c4a5dafd3d3530755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash map maximum bucket count. <br/></td></tr>
<tr class="separator:a13640ee401f0c75c4a5dafd3d3530755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50964014850fb653fe839d5df4c49fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa50964014850fb653fe839d5df4c49fb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#aa50964014850fb653fe839d5df4c49fb">key_hash</a> (const TKey &amp;key) const noexcept</td></tr>
<tr class="memdesc:aa50964014850fb653fe839d5df4c49fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate hash of the given key. <br/></td></tr>
<tr class="separator:aa50964014850fb653fe839d5df4c49fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13b31d5d3a46c301747caaad83fba76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa13b31d5d3a46c301747caaad83fba76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#aa13b31d5d3a46c301747caaad83fba76">key_equal</a> (const TKey &amp;key1, const TKey &amp;key2) const noexcept</td></tr>
<tr class="memdesc:aa13b31d5d3a46c301747caaad83fba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two keys: if the first key equals to the second one? <br/></td></tr>
<tr class="separator:aa13b31d5d3a46c301747caaad83fba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e793508e6cab0581ecbb255c3feeb30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e793508e6cab0581ecbb255c3feeb30"></a>
<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a6e793508e6cab0581ecbb255c3feeb30">begin</a> () noexcept</td></tr>
<tr class="memdesc:a6e793508e6cab0581ecbb255c3feeb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin hash map iterator. <br/></td></tr>
<tr class="separator:a6e793508e6cab0581ecbb255c3feeb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f75f7c0443618f603e3601fead5618"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86f75f7c0443618f603e3601fead5618"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a86f75f7c0443618f603e3601fead5618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8612ec560cb444582d631369d1d7584"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8612ec560cb444582d631369d1d7584"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:ac8612ec560cb444582d631369d1d7584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d18e31d30808a7ec6c7f76f4228d45e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d18e31d30808a7ec6c7f76f4228d45e"></a>
<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a4d18e31d30808a7ec6c7f76f4228d45e">end</a> () noexcept</td></tr>
<tr class="memdesc:a4d18e31d30808a7ec6c7f76f4228d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end hash map iterator. <br/></td></tr>
<tr class="separator:a4d18e31d30808a7ec6c7f76f4228d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8d15d8a49c5debf518964813b209c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b8d15d8a49c5debf518964813b209c6"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a9b8d15d8a49c5debf518964813b209c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccbdc3cc17589259afe00fde02fa7b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adccbdc3cc17589259afe00fde02fa7b4"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:adccbdc3cc17589259afe00fde02fa7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8033f558debcd15a9282f66345ba3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8033f558debcd15a9282f66345ba3d"></a>
<a class="el" href="class_x_t_1_1_hash_map_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a9d8033f558debcd15a9282f66345ba3d">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a9d8033f558debcd15a9282f66345ba3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse begin hash map iterator. <br/></td></tr>
<tr class="separator:a9d8033f558debcd15a9282f66345ba3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c5de36071134ed848e11173afe86a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c5de36071134ed848e11173afe86a7"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a96c5de36071134ed848e11173afe86a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009324309efa600fc860a6bc748b24c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a009324309efa600fc860a6bc748b24c7"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const noexcept</td></tr>
<tr class="separator:a009324309efa600fc860a6bc748b24c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42bfda88a5d961529bcba6b2f07d339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad42bfda88a5d961529bcba6b2f07d339"></a>
<a class="el" href="class_x_t_1_1_hash_map_reverse_iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ad42bfda88a5d961529bcba6b2f07d339">rend</a> () noexcept</td></tr>
<tr class="memdesc:ad42bfda88a5d961529bcba6b2f07d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reverse end hash map iterator. <br/></td></tr>
<tr class="separator:ad42bfda88a5d961529bcba6b2f07d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923cd15395b89e52bc551730ffa69e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0923cd15395b89e52bc551730ffa69e4"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:a0923cd15395b89e52bc551730ffa69e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7233bce8e13d8d99c06336dac09bbd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7233bce8e13d8d99c06336dac09bbd8"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_reverse_iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="separator:ac7233bce8e13d8d99c06336dac09bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02a111c98424f1716d04918e7766222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af02a111c98424f1716d04918e7766222"></a>
<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#af02a111c98424f1716d04918e7766222">find</a> (const TKey &amp;key) noexcept</td></tr>
<tr class="memdesc:af02a111c98424f1716d04918e7766222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the iterator which points to the first item with the given key in the hash map or return end iterator. <br/></td></tr>
<tr class="separator:af02a111c98424f1716d04918e7766222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20336c881f6b8873a604b622041fb44e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20336c881f6b8873a604b622041fb44e"></a>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const TKey &amp;key) const noexcept</td></tr>
<tr class="separator:a20336c881f6b8873a604b622041fb44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fda46998d99a452396ff48fb0b6178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0fda46998d99a452396ff48fb0b6178"></a>
std::pair&lt; <a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, <a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ab0fda46998d99a452396ff48fb0b6178">equal_range</a> (const TKey &amp;key) noexcept</td></tr>
<tr class="memdesc:ab0fda46998d99a452396ff48fb0b6178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the bounds of a range that includes all the elements in the hash map with the given key. <br/></td></tr>
<tr class="separator:ab0fda46998d99a452396ff48fb0b6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd9279c6b89417204783de052ad0bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9dd9279c6b89417204783de052ad0bb"></a>
std::pair&lt; <a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const TKey &amp;key) const noexcept</td></tr>
<tr class="separator:ab9dd9279c6b89417204783de052ad0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11822b891126acec265af0d403e6e486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11822b891126acec265af0d403e6e486"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a11822b891126acec265af0d403e6e486">count</a> (const TKey &amp;key) const noexcept</td></tr>
<tr class="memdesc:a11822b891126acec265af0d403e6e486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the count of items with the given key. <br/></td></tr>
<tr class="separator:a11822b891126acec265af0d403e6e486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7047d306e65c10eb89a395d90693e3b"><td class="memItemLeft" align="right" valign="top">mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#aa7047d306e65c10eb89a395d90693e3b">at</a> (const TKey &amp;key) noexcept</td></tr>
<tr class="memdesc:aa7047d306e65c10eb89a395d90693e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the item with the given key or throw std::out_of_range exception.  <a href="#aa7047d306e65c10eb89a395d90693e3b">More...</a><br/></td></tr>
<tr class="separator:aa7047d306e65c10eb89a395d90693e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57bad62556e8defe594421cb2f2be3f"><td class="memItemLeft" align="right" valign="top">const mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ab57bad62556e8defe594421cb2f2be3f">at</a> (const TKey &amp;key) const noexcept</td></tr>
<tr class="memdesc:ab57bad62556e8defe594421cb2f2be3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the constant item with the given key or throw std::out_of_range exception.  <a href="#ab57bad62556e8defe594421cb2f2be3f">More...</a><br/></td></tr>
<tr class="separator:ab57bad62556e8defe594421cb2f2be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34af418014420214cb673fe0cc77d3de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a34af418014420214cb673fe0cc77d3de">insert</a> (const value_type &amp;item)</td></tr>
<tr class="memdesc:a34af418014420214cb673fe0cc77d3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the hash map.  <a href="#a34af418014420214cb673fe0cc77d3de">More...</a><br/></td></tr>
<tr class="separator:a34af418014420214cb673fe0cc77d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad08bb58d5cd90c39ae68649642dbc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a13ad08bb58d5cd90c39ae68649642dbc">insert</a> (value_type &amp;&amp;item)</td></tr>
<tr class="memdesc:a13ad08bb58d5cd90c39ae68649642dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item into the hash map.  <a href="#a13ad08bb58d5cd90c39ae68649642dbc">More...</a><br/></td></tr>
<tr class="separator:a13ad08bb58d5cd90c39ae68649642dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189706954cfc3b9930a096575a4e894"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3189706954cfc3b9930a096575a4e894"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a3189706954cfc3b9930a096575a4e894">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3189706954cfc3b9930a096575a4e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new item into the hash map.  <a href="#a3189706954cfc3b9930a096575a4e894">More...</a><br/></td></tr>
<tr class="separator:a3189706954cfc3b9930a096575a4e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec741c57c6aa9d10daa4ab0f0229cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#af5ec741c57c6aa9d10daa4ab0f0229cc">erase</a> (const TKey &amp;key)</td></tr>
<tr class="memdesc:af5ec741c57c6aa9d10daa4ab0f0229cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the item with the given key from the hash map.  <a href="#af5ec741c57c6aa9d10daa4ab0f0229cc">More...</a><br/></td></tr>
<tr class="separator:af5ec741c57c6aa9d10daa4ab0f0229cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61da1f1504da0befa1a7c896f7fef2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a61da1f1504da0befa1a7c896f7fef2eb">erase</a> (const <a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a> &amp;position)</td></tr>
<tr class="memdesc:a61da1f1504da0befa1a7c896f7fef2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the item by its iterator from the hash map.  <a href="#a61da1f1504da0befa1a7c896f7fef2eb">More...</a><br/></td></tr>
<tr class="separator:a61da1f1504da0befa1a7c896f7fef2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad067ca874fdcc5bcc10ae8eb0b605083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ad067ca874fdcc5bcc10ae8eb0b605083">rehash</a> (size_t capacity)</td></tr>
<tr class="memdesc:ad067ca874fdcc5bcc10ae8eb0b605083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehash the hash map to the given capacity or more.  <a href="#ad067ca874fdcc5bcc10ae8eb0b605083">More...</a><br/></td></tr>
<tr class="separator:ad067ca874fdcc5bcc10ae8eb0b605083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87db89a779b38cf0f4de806d0674893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#aa87db89a779b38cf0f4de806d0674893">reserve</a> (size_t <a class="el" href="class_x_t_1_1_hash_map.html#a11822b891126acec265af0d403e6e486">count</a>)</td></tr>
<tr class="memdesc:aa87db89a779b38cf0f4de806d0674893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the hash map capacity to fit the given count of items.  <a href="#aa87db89a779b38cf0f4de806d0674893">More...</a><br/></td></tr>
<tr class="separator:aa87db89a779b38cf0f4de806d0674893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dc5e2f2f45e10d547697b5839f59a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06dc5e2f2f45e10d547697b5839f59a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#a06dc5e2f2f45e10d547697b5839f59a9">clear</a> () noexcept</td></tr>
<tr class="memdesc:a06dc5e2f2f45e10d547697b5839f59a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the hash map. <br/></td></tr>
<tr class="separator:a06dc5e2f2f45e10d547697b5839f59a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada63d2bc1587e1454e11a9bea650c4c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada63d2bc1587e1454e11a9bea650c4c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_t_1_1_hash_map.html#ada63d2bc1587e1454e11a9bea650c4c3">swap</a> (<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> &amp;hashmap) noexcept</td></tr>
<tr class="memdesc:ada63d2bc1587e1454e11a9bea650c4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two instances. <br/></td></tr>
<tr class="separator:ada63d2bc1587e1454e11a9bea650c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f845c58c79649ba09aee81c79ce5ab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46f845c58c79649ba09aee81c79ce5ab"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a46f845c58c79649ba09aee81c79ce5ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a><br class="typebreak"/>
&lt; TKey, TValue, THash, TEqual, <br class="typebreak"/>
TAllocator &gt;::<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a46f845c58c79649ba09aee81c79ce5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa0c4ee056b11dc2962a85aba0b83b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="adaa0c4ee056b11dc2962a85aba0b83b8"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adaa0c4ee056b11dc2962a85aba0b83b8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a><br class="typebreak"/>
&lt; TKey, TValue, THash, TEqual, <br class="typebreak"/>
TAllocator &gt;::<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_internal</b> (const TKey &amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="separator:adaa0c4ee056b11dc2962a85aba0b83b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8db4cb7079469019999a2a6f5378f6e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8db4cb7079469019999a2a6f5378f6e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HashMapIterator&lt; HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt;, TKey, TValue &gt;</b></td></tr>
<tr class="separator:a8db4cb7079469019999a2a6f5378f6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb9ee0eccde273c5c80608e99093c0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb9ee0eccde273c5c80608e99093c0e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HashMapConstIterator&lt; HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt;, TKey, TValue &gt;</b></td></tr>
<tr class="separator:aacb9ee0eccde273c5c80608e99093c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37ed1fce08ae5d54a8097493cc8843f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37ed1fce08ae5d54a8097493cc8843f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HashMapReverseIterator&lt; HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt;, TKey, TValue &gt;</b></td></tr>
<tr class="separator:ae37ed1fce08ae5d54a8097493cc8843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4827ab2321cefea0bee13f68c048ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d4827ab2321cefea0bee13f68c048ae"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HashMapConstReverseIterator&lt; HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt;, TKey, TValue &gt;</b></td></tr>
<tr class="separator:a5d4827ab2321cefea0bee13f68c048ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fffbe5d37e525bfdf0d60650bb71ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9fffbe5d37e525bfdf0d60650bb71ef"></a>
template&lt;typename UKey , typename UValue , typename UHash , typename UEqual , typename UAllocator &gt; </td></tr>
<tr class="memitem:ac9fffbe5d37e525bfdf0d60650bb71ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; UKey, UValue, UHash, UEqual, UAllocator &gt; &amp;hashmap1, <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; UKey, UValue, UHash, UEqual, UAllocator &gt; &amp;hashmap2) noexcept</td></tr>
<tr class="separator:ac9fffbe5d37e525bfdf0d60650bb71ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKey, typename TValue, typename THash = std::hash&lt;TKey&gt;, typename TEqual = std::equal_to&lt;TKey&gt;, typename TAllocator = std::allocator&lt;std::pair&lt;TKey, TValue&gt;&gt;&gt;<br/>
class XT::HashMap&lt; TKey, TValue, THash, TEqual, TAllocator &gt;</h3>

<p>Hash map container. </p>
<p>Hash map is an efficient structure for associative keys/value storing and accessing without keeping order. It uses hash function to convert string key into the integer and use the index to quick access value data.</p>
<p>Open address hash map resolves collisions of the same hash values by inserting new item into the next free place (probing with step 1).</p>
<p>Not thread-safe. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a47a7869a515c91f58c9d91c00e7409ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue , typename THash, typename TEqual, typename TAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::<a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>blank</em> = <code>TKey()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const THash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>THash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>TEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>TAllocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the hash map with a given capacity and blank key value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- Hash map capacity (default is 128) </td></tr>
    <tr><td class="paramname">blank</td><td>- Blank key value (default is TKey()) </td></tr>
    <tr><td class="paramname">hash</td><td>- Key hasher (default is THash()) </td></tr>
    <tr><td class="paramname">equal</td><td>- Key comparator (default is THash()) </td></tr>
    <tr><td class="paramname">allocator</td><td>- <a class="el" href="class_x_t_1_1_allocator.html" title="Memory allocator class. ">Allocator</a> (default is TAllocator()) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa7047d306e65c10eb89a395d90693e3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::mapped_type &amp; <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the item with the given key or throw std::out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- Key of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Item with the given key </dd></dl>

</div>
</div>
<a class="anchor" id="ab57bad62556e8defe594421cb2f2be3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::mapped_type &amp; <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the constant item with the given key or throw std::out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- Key of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant item with the given key </dd></dl>

</div>
</div>
<a class="anchor" id="a3189706954cfc3b9930a096575a4e894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue, typename THash = std::hash&lt;TKey&gt;, typename TEqual = std::equal_to&lt;TKey&gt;, typename TAllocator = std::allocator&lt;std::pair&lt;TKey, TValue&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool&gt; <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emplace a new item into the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Arguments to emplace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the given key and success flag </dd></dl>

</div>
</div>
<a class="anchor" id="af5ec741c57c6aa9d10daa4ab0f0229cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the item with the given key from the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- Key of the item to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of erased elements (0 or 1 for the hash map) </dd></dl>

</div>
</div>
<a class="anchor" id="a61da1f1504da0befa1a7c896f7fef2eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_t_1_1_hash_map_const_iterator.html">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the item by its iterator from the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>- Iterator position to the erased item </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34af418014420214cb673fe0cc77d3de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to insert as a key/value pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the given key and success flag </dd></dl>

</div>
</div>
<a class="anchor" id="a13ad08bb58d5cd90c39ae68649642dbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_x_t_1_1_hash_map.html">HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::<a class="el" href="class_x_t_1_1_hash_map_iterator.html">iterator</a>, bool &gt; <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item into the hash map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- Item to insert as a key/value pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair with the iterator to the given key and success flag </dd></dl>

</div>
</div>
<a class="anchor" id="ad067ca874fdcc5bcc10ae8eb0b605083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehash the hash map to the given capacity or more. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>- Hash map capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa87db89a779b38cf0f4de806d0674893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue , typename THash , typename TEqual , typename TAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_x_t_1_1_hash_map.html">XT::HashMap</a>&lt; TKey, TValue, THash, TEqual, TAllocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve the hash map capacity to fit the given count of items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- Count of items to fit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/xtcommon/xtcontainer/<a class="el" href="_x_t_hash_map_8h_source.html">XTHashMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 13 2021 01:11:41 for xtcommon by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
